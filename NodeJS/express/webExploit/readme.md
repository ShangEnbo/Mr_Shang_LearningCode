# web开发模式

1. 基于服务端渲染的传统Web开发模式

    服务器发送给客户端的HTML页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用Ajax这样的技术额外请求页面的数据

    **优点**

    - 前端耗时少。 因为服务端负责动态生成HTML内容，浏览器只需要直接渲染页面。尤其是移动端，更省电

    - 有利于SEO。 因为服务端响应的是完整的HTML内容，所以爬虫更容易爬去获得信息，更有利于SEO

    **缺点**

    - 占用服务端资源。 服务端完成HTML页面内容的拼接。如果请求过多，会对服务器造成一定的访问压力

    - 不利于前后端分离，开发效率低。 无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发


2. 基于前后端分离的新型Web开发模式

    依赖于Ajax技术。后端只负责提供API接口，前端使用Ajax调用接口的开发模式

    **优点**

    - 开发体验好。 专注于UI页面的开发，后端专注于api的开发，且前端有更多的选择性。

    - 用户体验好。 可以轻松实现页面的局部刷新

    - 减轻服务端的渲染压力。 因为页面是在每个用户的浏览器中生成的

    **缺点**

    - 不利于SEO。 因为完整的HTML页面需要在客户端动态拼接完成，所以爬虫无法爬取页面的有效信息。（利用Vue、React等前端框架的SSR技术能够很好的解决SEO问题）


# 如何选择Web开发模式

不谈业务场景而盲目选择使用何种开发模式都是耍流氓

- 企业级网站， 主要功能是展示而没有复杂的交互，并且需要良好的SEO，此时我们需要使用服务端渲染

- 后台管理项目， 交互性比较强，不需要考虑SEO，那么就可以使用前后端分离的开发模式

为了同时兼顾首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器渲染 + 其他页面前后端分离的开发模式


# 身份认证（鉴权）

通过一定手段，完成对用户身份的确认

## 不同的开发模式下的身份认证

1. 服务端渲染使用`Session`

2. 前后端分离渲染使用`JWT认证机制`

## Session认证机制

1. HTTP协议的无状态性，服务端不会记住每次请求

2. Cookie

    Cookie是存储在用户浏览器中的一段不超过4KB的字符串，它由一个名称、一个值和其他用于控制Cookie有效期、安全性、使用范围的可选属性组成。

    不同域名下的Cookie各自独立，每当客户端发起请求，会自动把当前域名下所有未过期的Cookie一同发送到服务器。

    特性：自动发送，域名独立，过期时限，4KB限制

3. Cookie在身份认证中的作用

    客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie保存在服务器中。

    随后，当客户端每次请求服务器时，浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端身份

4. Cookie不具有安全性

    Cookie是存储在浏览器中的，而且浏览器提供了读写Cookie的API，因此Cookie很容易被伪造，不具有安全性，因此不要将重要的隐私数据放在Cookie中

5. Session的工作原理

    ```js
    // 导入 express 模块
    const express = require('express')

    // 创建 express 的服务器实例
    const app = express()

    // 导入 express-session 模块
    const session = require('express-session')

    // 配置 session 中间件
    app.use(
      session({
        secret: 'keyboard cat',
        resave: false,
        saveUninitialized: true
      })
    )
    ```
    **向session中存数据**

    express-session中间件配置成功之后，即可通过 req.session 来访问和使用 session 对象，从而存储用户的关键信息

    当第一次进行session认证时，会给请求加一个set-Cookie字段，响应头携带Cookie进行认证

# JWT认证机制

Session认证的局限性

Session认证机制需要配合Cookie才能实现，由于Cookie默认不支持跨域访问，所以当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域Session认证

JWT

JWT（JSON Web Token） 是目前最流行的跨域认证解决方案

JWT的工作原理

JWT的组成部分

- Header 头部

    安全性相关的部分，只是为了保证Token的安全性

- Payload 有效载荷

    真正的用户信息，它是用户信息经过加密之后生成的字符串

- Signature 签名

    安全性相关的部分，只是为了保证Token的安全性

三部分用英文'.'分隔  `Header.Payload.Signature`

JWT的使用方式

客户端收到服务器返回的JWT之后，通常会将它存储在localStorage或sessionStorage中

此后，客户端每次与服务器通信，都要带上这个JWT的字符串，进行身份认证。推荐的做法是把JWT放在HTTP请求头的Authorization字段中，格式如下：

`Authorization: Bearer <token>`

安装JWT相关的包

- jsonwebtoken 用于生成JWT字符串

- express-jwt 用于将JWT字符串解析还原成JSON对象

定义 secret 密钥

为了保证JWT字符串的安全性，防止JWT字符串在网络传输中被别人破解，需要专门定义一个用于加密和解密的secret密钥

- 当生成JWT字符串时，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 JWT 字符串

    ```js
    // 生成jwt字符串
    /**
     * 参数1 用户的信息对象
    * 参数2 加密的密钥
    * 参数3 配置对象，可以配置当前token的有效期
    */
    const tokenstr = jwt.sign({username: userinfo.username}, secretkey, { expiresIn: '60s' })
    res.send({
      status: 0,
      msg: '登录成功',
      data: tokenstr
    })
    ```

- 当把JWT字符串解析还原成JSON对象时，需要使用secret密钥进行解密

    > 将JWT字符串还原为JSON对象

    > 客户端每次在访问那些有权限的接口的时候，都需要主动通过请求头中的 Authorization 字段，将Token字符串发出送到服务器进行身份认证。

    > 此时，通过服务器可以通过 express-jwt 这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象

    expressJWT({ secret: secretKey }) 用来解析 Token 的中间件

    .unless({ path: [/^\/api\//] })  用来指定哪些接口不需要访问权限

    配置成功了 express-jwt 这个中间件后，就可以把解析出来的信息，挂载到 req.user 属性上

捕获解析JWT失败后产生的错误

当使用 express-jwt 解析Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行，我们可以通过 错误中间件 ，捕获这个错误，并进行相关的处理
